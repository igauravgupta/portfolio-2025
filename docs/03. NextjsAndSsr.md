# Next.js Implementation & SSR

Deep dive into how Next.js is implemented in this portfolio project and how Server-Side Rendering (SSR) works.

## App Router Architecture (Next.js 13+)

This project uses the **App Router**, introduced in Next.js 13 and stable in Next.js 15.

### Key Concepts

#### 1. Server Components by Default

In the App Router, **all components are Server Components by default** unless marked with `"use client"`.

**`app/layout.tsx`** (Server Component):

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  variable: "--font-inter",
});

export const metadata: Metadata = {
  title: "Gaurav Gupta",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className={`${inter.variable}`}>
      <body className="font-sans antialiased">{children}</body>
    </html>
  );
}
```

**Benefits:**

- ✅ **SEO-friendly**: HTML rendered on server includes metadata
- ✅ **Zero JavaScript**: Layout doesn't ship client-side JS
- ✅ **Font Optimization**: `next/font` optimizes font loading automatically
- ✅ **Fast Initial Load**: No hydration needed for static parts

#### 2. Client Components

**`app/page.tsx`** (Client Component):

```tsx
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";

export default function Home() {
  const [isDark, setIsDark] = useState(true);
  const [activeSection, setActiveSection] = useState("");

  useEffect(() => {
    document.documentElement.classList.toggle("dark", isDark);
  }, [isDark]);

  const toggleTheme = () => {
    setIsDark(!isDark);
  };

  return (
    <div>
      <button onClick={toggleTheme}>Toggle Theme</button>
      {/* ... */}
    </div>
  );
}
```

**Why "use client"?**

- Uses React hooks (`useState`, `useEffect`)
- Requires browser APIs (DOM manipulation)
- Has event handlers and interactivity
- Needs access to `window` or `document`

### File-Based Routing

```
app/
├── page.tsx                → /
├── layout.tsx              → Root layout
├── loading.tsx             → Loading UI
├── error.tsx               → Error handling
├── not-found.tsx           → 404 page
│
├── about/
│   └── page.tsx            → /about
│
├── blog/
│   ├── page.tsx            → /blog
│   └── [slug]/
│       └── page.tsx        → /blog/:slug
│
└── api/
    └── hello/
        └── route.ts        → /api/hello
```

**Special Files:**

- `page.tsx` - Route UI
- `layout.tsx` - Shared UI wrapper
- `loading.tsx` - Loading skeleton
- `error.tsx` - Error boundary
- `not-found.tsx` - 404 page
- `route.ts` - API endpoint

## Server-Side Rendering (SSR)

### How SSR Works in This Project

#### Request Flow

```
1. User requests page
   ↓
2. Next.js Server receives request
   ↓
3. Runs Server Components
   ├─ Fetches data (if needed)
   ├─ Executes layout.tsx
   └─ Renders page.tsx (marks client boundaries)
   ↓
4. Generates HTML
   ├─ Includes all Server Component output
   ├─ Placeholder for Client Components
   └─ Metadata in <head>
   ↓
5. Sends to browser
   ├─ Full HTML (immediate display)
   ├─ Client Component JS bundles
   └─ React runtime
   ↓
6. Browser hydrates Client Components
   ├─ Attaches event listeners
   ├─ Initializes state
   └─ Makes page interactive
```

#### Visual Timeline

```
Server Side:
├─ 0ms: Request received
├─ 10ms: Run Server Components
├─ 20ms: Fetch data (if needed)
├─ 50ms: Render to HTML
└─ 60ms: Send response (TTFB)

Client Side:
├─ 60ms: HTML arrives (FCP - Fast!)
├─ 100ms: Download JS bundles
├─ 200ms: React hydration starts
└─ 300ms: Page interactive (TTI)
```

### SSR Configuration

**`next.config.mjs`**:

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true, // ⚠️ Not recommended for production
  },
  typescript: {
    ignoreBuildErrors: true, // ⚠️ Not recommended for production
  },
  images: {
    unoptimized: true, // Disable Next.js image optimization
  },
};

export default nextConfig;
```

**Configuration Notes:**

- `ignoreDuringBuilds` - Skips ESLint during build (development convenience)
- `ignoreBuildErrors` - Ignores TypeScript errors (use carefully)
- `unoptimized: true` - Useful for static hosting without Node.js server

### Rendering Strategies Available

Next.js supports multiple rendering strategies:

| Strategy          | When          | How                      | Use Case                       |
| ----------------- | ------------- | ------------------------ | ------------------------------ |
| **SSR** (Default) | Every request | Server renders HTML      | Dynamic, personalized content  |
| **SSG**           | Build time    | Pre-renders static HTML  | Blogs, docs, marketing pages   |
| **ISR**           | Periodic      | Regenerates static pages | Content that updates regularly |
| **Client-Side**   | In browser    | Fetches data after load  | Dashboards, private data       |

#### 1. Server-Side Rendering (SSR)

```tsx
// Default in App Router - no special config needed
export default async function Page() {
  const data = await fetch("https://api.example.com/data", {
    cache: "no-store", // Force fresh data
  });
  const json = await data.json();

  return <div>{json.title}</div>;
}
```

**When to use:**

- Real-time data required
- Personalized content
- SEO-critical dynamic pages

#### 2. Static Site Generation (SSG)

```tsx
// Cached by default, regenerated on each build
export default async function Page() {
  const data = await fetch("https://api.example.com/data", {
    cache: "force-cache", // Default behavior
  });
  const json = await data.json();

  return <div>{json.title}</div>;
}

// Generate static paths
export async function generateStaticParams() {
  const posts = await fetchAllPosts();

  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

**When to use:**

- Content doesn't change often
- Best performance needed
- Many pages to pre-generate

#### 3. Incremental Static Regeneration (ISR)

```tsx
export default async function Page() {
  const data = await fetch("https://api.example.com/data", {
    next: { revalidate: 60 }, // Revalidate every 60 seconds
  });
  const json = await data.json();

  return <div>{json.title}</div>;
}
```

**When to use:**

- Content updates periodically
- Balance between fresh and fast
- Reduces server load

#### 4. Client-Side Rendering

```tsx
"use client";

import { useEffect, useState } from "react";

export default function Page() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/data")
      .then((res) => res.json())
      .then(setData);
  }, []);

  if (!data) return <div>Loading...</div>;
  return <div>{data.title}</div>;
}
```

**When to use:**

- Private/authenticated data
- Real-time updates (WebSocket)
- No SEO needed

## Built-in Optimizations

### 1. Font Optimization

```tsx
import { Inter } from "next/font/google";

const inter = Inter({
  subsets: ["latin"], // Only load Latin characters
  display: "swap", // FOUT prevention
  variable: "--font-inter", // CSS variable
});
```

**Benefits:**

- Self-hosts fonts (no external requests)
- Automatic font subsetting
- Optimal loading strategy
- Zero Cumulative Layout Shift (CLS)

**Under the hood:**

```html
<!-- Next.js generates this: -->
<style data-href="https://fonts.googleapis.com/css2?family=Inter">
  @font-face {
    font-family: "__Inter_123abc";
    src: url(/_next/static/media/abc123.woff2) format("woff2");
    font-display: swap;
  }
</style>
```

### 2. Metadata API

```tsx
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Gaurav Gupta",
  description: "Portfolio website",
  openGraph: {
    title: "Gaurav Gupta",
    description: "Portfolio website",
    images: ["/og-image.jpg"],
  },
  twitter: {
    card: "summary_large_image",
  },
};
```

**Generates:**

```html
<head>
  <title>Gaurav Gupta</title>
  <meta name="description" content="Portfolio website" />
  <meta property="og:title" content="Gaurav Gupta" />
  <meta property="og:description" content="Portfolio website" />
  <meta property="og:image" content="/og-image.jpg" />
  <meta name="twitter:card" content="summary_large_image" />
</head>
```

**Benefits:**

- Type-safe metadata
- Automatic SEO optimization
- No manual `<head>` management
- Supports all meta tags

### 3. Automatic Code Splitting

```
Every route automatically gets its own bundle:

/_next/static/chunks/
├── app/page.js          (Home page)
├── app/about/page.js    (About page)
├── app/blog/page.js     (Blog page)
└── shared/              (Common dependencies)
```

**Benefits:**

- Only load code for current page
- Parallel loading of shared chunks
- Optimal bundle sizes
- Automatic prefetching

### 4. Link Prefetching

```tsx
import Link from "next/link";

export default function Nav() {
  return (
    <nav>
      <Link href="/about">About</Link> {/* Prefetches on hover */}
      <Link href="/blog" prefetch={false}>
        Blog
      </Link> {/* No prefetch */}
    </nav>
  );
}
```

**Behavior:**

- Prefetches on link hover (viewport)
- Instant navigation
- Smart prefetching (production only)
- Configurable per link

## Performance Metrics

### Lighthouse Score Expectations

With proper SSR implementation:

```
Performance:     90-100
Accessibility:   90-100
Best Practices:  90-100
SEO:            90-100

Core Web Vitals:
├─ LCP: < 2.5s     (Largest Contentful Paint)
├─ FID: < 100ms    (First Input Delay)
└─ CLS: < 0.1      (Cumulative Layout Shift)
```

### Monitoring Performance

```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        {process.env.NODE_ENV === "production" && (
          <script
            dangerouslySetInnerHTML={{
              __html: `
                // Web Vitals tracking
                new PerformanceObserver((list) => {
                  for (const entry of list.getEntries()) {
                    console.log(entry.name, entry.startTime);
                  }
                }).observe({ entryTypes: ['paint', 'largest-contentful-paint'] });
              `,
            }}
          />
        )}
      </body>
    </html>
  );
}
```

## Best Practices

### ✅ Do's

1. **Use Server Components by default**

   ```tsx
   // Good - Server Component (default)
   async function Page() {
     const data = await fetchData();
     return <div>{data}</div>;
   }
   ```

2. **Add "use client" only when needed**

   ```tsx
   // Good - Client Component only for interactivity
   "use client";
   function InteractiveWidget() {
     const [state, setState] = useState();
     return <button onClick={() => setState()}>Click</button>;
   }
   ```

3. **Fetch data on the server**
   ```tsx
   // Good - Secure, fast, SEO-friendly
   async function Page() {
     const data = await db.query("SELECT * FROM users");
     return <UserList users={data} />;
   }
   ```

### ❌ Don'ts

1. **Don't use "use client" everywhere**

   ```tsx
   // Bad - Unnecessary client component
   "use client";
   function StaticContent() {
     return <div>Static text</div>;
   }
   ```

2. **Don't fetch data in useEffect when SSR is available**

   ```tsx
   // Bad - Slow, no SEO, waterfall requests
   "use client";
   function Page() {
     const [data, setData] = useState();
     useEffect(() => {
       fetch("/api/data")
         .then((r) => r.json())
         .then(setData);
     }, []);
   }
   ```

3. **Don't ignore TypeScript/ESLint errors in production**
   ```javascript
   // Bad - next.config.mjs
   {
     typescript: { ignoreBuildErrors: true },  // ❌
     eslint: { ignoreDuringBuilds: true }      // ❌
   }
   ```

---

**Previous:** [← Dependencies](./02-dependencies.md) | **Next:** [React vs Next.js →](./04-react-vs-nextjs.md)
