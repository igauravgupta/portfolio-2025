# React.js vs Next.js

Comprehensive comparison between React.js and Next.js to help you choose the right framework for your project.

## Core Differences

| Aspect                 | React.js                    | Next.js                            |
| ---------------------- | --------------------------- | ---------------------------------- |
| **Type**               | Library                     | Framework (built on React)         |
| **Rendering**          | Client-Side Only (CSR)      | SSR, SSG, ISR, CSR                 |
| **Routing**            | Requires React Router       | Built-in file-based routing        |
| **SEO**                | Poor (requires workarounds) | Excellent (server-rendered HTML)   |
| **Performance**        | Good (optimizations manual) | Excellent (built-in optimizations) |
| **Code Splitting**     | Manual with React.lazy      | Automatic per route                |
| **Image Optimization** | Manual                      | Built-in `next/image`              |
| **API Routes**         | Requires separate backend   | Built-in API routes                |
| **Configuration**      | Minimal (CRA) or manual     | Convention-based with config       |
| **Build Size**         | Smaller initial bundle      | Larger but optimized chunks        |
| **Deployment**         | Static hosting              | Needs Node.js server (or Edge)     |
| **Learning Curve**     | Easier                      | Steeper (more concepts)            |
| **Flexibility**        | High                        | Medium (opinionated)               |

## Detailed Comparison

### 1. Rendering Methods

#### React.js (CSR Only)

```tsx
// Client-Side Rendering only
function App() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("/api/data")
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  return <div>{data?.title}</div>;
}
```

**Problems:**

- âŒ Blank page until JavaScript loads
- âŒ Poor SEO (crawlers see empty HTML)
- âŒ Slow First Contentful Paint (FCP)
- âŒ Multiple round trips (HTML â†’ JS â†’ Data)

**What the browser receives:**

```html
<html>
  <body>
    <div id="root"></div>
    <!-- Empty! -->
    <script src="bundle.js"></script>
  </body>
</html>
```

#### Next.js (Multiple Strategies)

**Server-Side Rendering (SSR):**

```tsx
// Runs on server for every request
export default async function Page() {
  const data = await fetch("https://api.example.com/data");
  const json = await data.json();

  return <div>{json.title}</div>;
}
```

**Static Site Generation (SSG):**

```tsx
// Pre-rendered at build time
export default async function Page() {
  const data = await fetch("https://api.example.com/data", {
    cache: "force-cache",
  });
  const json = await data.json();

  return <div>{json.title}</div>;
}
```

**Benefits:**

- âœ… HTML rendered on server
- âœ… Instant content display
- âœ… SEO-friendly
- âœ… Faster perceived performance

**What the browser receives:**

```html
<html>
  <body>
    <div>Actual Content Here!</div>
    <!-- Full HTML! -->
    <script src="bundle.js"></script>
  </body>
</html>
```

### 2. Routing

#### React.js (React Router)

```tsx
// Manual setup required
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/blog/123">Blog Post</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/blog/:id" element={<BlogPost />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

**Characteristics:**

- Configuration-based routing
- Manual code splitting setup
- Requires separate 404 handling
- No automatic prefetching

#### Next.js (File-based Routing)

```
app/
â”œâ”€â”€ page.tsx              â†’ /
â”œâ”€â”€ about/
â”‚   â””â”€â”€ page.tsx          â†’ /about
â”œâ”€â”€ blog/
â”‚   â””â”€â”€ [id]/
â”‚       â””â”€â”€ page.tsx      â†’ /blog/:id
â””â”€â”€ not-found.tsx         â†’ 404 page
```

```tsx
// app/page.tsx
export default function Home() {
  return <div>Home</div>;
}

// Automatic routing, no configuration!
```

**Characteristics:**

- File-based routing (zero config)
- Automatic code splitting per route
- Built-in 404 handling
- Automatic prefetching with `<Link>`
- Nested layouts support

### 3. Data Fetching

#### React.js

```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then((res) => {
        if (!res.ok) throw new Error("Failed");
        return res.json();
      })
      .then((data) => {
        setUser(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [userId]);

  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;
  return <div>{user.name}</div>;
}
```

**Characteristics:**

- Manual loading states
- Manual error handling
- Runs in browser (client-side)
- Can't access backend directly
- Race conditions possible

#### Next.js (Server Component)

```tsx
async function UserProfile({ userId }) {
  const user = await fetchUser(userId);

  return <div>{user.name}</div>;
}
```

**Characteristics:**

- No loading states needed
- Automatic error boundaries
- Runs on server (secure)
- Direct database access
- No race conditions
- Automatic request deduplication

### 4. Performance Optimizations

| Feature                | React.js                       | Next.js                 |
| ---------------------- | ------------------------------ | ----------------------- |
| **Code Splitting**     | Manual with `React.lazy()`     | Automatic per route     |
| **Image Optimization** | Manual (srcset, WebP, etc.)    | `<Image>` component     |
| **Font Optimization**  | Manual loading                 | `next/font`             |
| **Prefetching**        | Manual with Service Worker     | Automatic with `<Link>` |
| **Bundle Analysis**    | Manual webpack-bundle-analyzer | Built-in analyzer       |
| **Tree Shaking**       | Webpack/Vite config            | Built-in                |
| **Minification**       | Manual Terser config           | Built-in                |

**Example: Image Optimization**

React.js:

```tsx
<img
  src="/image.jpg"
  srcSet="/image-400.jpg 400w, /image-800.jpg 800w"
  sizes="(max-width: 400px) 400px, 800px"
  loading="lazy"
  alt="Description"
/>
```

Next.js:

```tsx
import Image from "next/image";

<Image src="/image.jpg" width={800} height={600} alt="Description" />;
// Automatically optimizes, lazy loads, generates WebP, etc.
```

### 5. SEO Capabilities

#### React.js

```html
<!-- What Google sees with React CSR: -->
<html>
  <head>
    <title>React App</title>
  </head>
  <body>
    <div id="root"></div>
    <!-- Empty! -->
    <script src="bundle.js"></script>
  </body>
</html>
```

**SEO Challenges:**

- Requires JavaScript to render content
- Google waits for JavaScript execution
- Slower indexing
- Poor social media previews (no Open Graph)
- Requires workarounds (Prerendering, SSR library)

#### Next.js

```html
<!-- What Google sees with Next.js SSR: -->
<html>
  <head>
    <title>Gaurav Gupta - Portfolio</title>
    <meta name="description" content="Full-stack developer..." />
    <meta property="og:title" content="Gaurav Gupta" />
    <meta property="og:image" content="/og-image.jpg" />
  </head>
  <body>
    <header>
      <h1>Welcome to my portfolio</h1>
      <p>I'm a full-stack developer...</p>
    </header>
    <!-- Fully rendered HTML content -->
  </body>
</html>
```

**SEO Benefits:**

- Fully rendered HTML
- Instant indexing
- Perfect social media previews
- Metadata API for type-safe SEO
- Structured data support

### 6. API Routes

#### React.js

Requires separate backend:

```tsx
// Need Express, Fastify, or another backend
// server.js
const express = require("express");
const app = express();

app.get("/api/users", (req, res) => {
  res.json({ users: [] });
});

app.listen(3001);
```

Then fetch from React:

```tsx
const response = await fetch("http://localhost:3001/api/users");
```

#### Next.js

Built-in API routes:

```tsx
// app/api/users/route.ts
export async function GET() {
  const users = await db.query("SELECT * FROM users");
  return Response.json({ users });
}
```

Fetch from component:

```tsx
const response = await fetch("/api/users");
```

**Benefits:**

- No separate backend needed
- Same codebase
- Automatic deployment
- TypeScript support
- Middleware support

## When to Choose Each

### âœ… Choose Next.js When:

#### 1. SEO is Critical

- **E-commerce stores** - Product pages need to rank
- **Blogs & content sites** - Articles need indexing
- **Marketing websites** - Landing pages need visibility
- **SaaS landing pages** - Attract organic traffic
- **News sites** - Real-time content indexing

**Example:**

```tsx
// E-commerce product page with perfect SEO
export const metadata = {
  title: "Premium Headphones - $199",
  description: "High-quality wireless headphones...",
  openGraph: {
    images: ["/product-image.jpg"],
  },
};

export default async function ProductPage({ params }) {
  const product = await fetchProduct(params.id);

  return (
    <div itemScope itemType="https://schema.org/Product">
      <h1 itemProp="name">{product.name}</h1>
      <span itemProp="price">${product.price}</span>
    </div>
  );
}
```

#### 2. Performance is Critical

- **Mobile-first applications** - Fast initial load
- **Core Web Vitals matter** - Google ranking factor
- **Global audience** - Edge rendering
- **Low-end devices** - Reduced JavaScript

#### 3. Full-Stack Application Needed

- **Unified codebase** - Frontend + Backend together
- **API endpoints** - Built-in serverless functions
- **Authentication** - Server-side session handling
- **Database access** - Direct from Server Components

#### 4. Complex Routing Requirements

- **Multi-page application** - Many routes
- **Nested layouts** - Shared UI across routes
- **Dynamic routes** - `/blog/[slug]`, `/user/[id]`
- **Parallel routes** - Multiple sections simultaneously

#### 5. Built-in Features Needed

- **Image optimization** - Automatic WebP, lazy loading
- **Font optimization** - Self-hosted, subset fonts
- **Internationalization** - Multi-language support
- **Analytics** - Built-in Web Vitals tracking

### âœ… Choose React.js When:

#### 1. Single Page Application (SPA)

- **Interactive dashboards** - Real-time data visualization
- **Admin panels** - Internal tools, no SEO needed
- **Trading platforms** - High interactivity
- **Design tools** - Canvas-based applications

**Example:**

```tsx
// Real-time dashboard - no SSR needed
function Dashboard() {
  const [data, setData] = useState([]);

  useEffect(() => {
    const ws = new WebSocket("ws://api.example.com");
    ws.onmessage = (event) => {
      setData(JSON.parse(event.data));
    };
  }, []);

  return <Chart data={data} />;
}
```

#### 2. SEO Not Required

- **Behind login pages** - Private content
- **Internal applications** - Employee tools
- **B2B platforms** - Not consumer-facing
- **Developer tools** - API explorers, debuggers

#### 3. Simple/Small Projects

- **Prototypes** - Quick POCs
- **Learning projects** - Focus on React fundamentals
- **Landing pages** (static) - No dynamic content
- **Portfolios** (if SEO not critical)

#### 4. Existing Infrastructure

- **Separate backend** - Already have API
- **Microservices** - React is just one piece
- **Mobile apps** - React Native codebase sharing
- **Legacy systems** - Gradual migration

#### 5. Maximum Flexibility Needed

- **Custom build setup** - Webpack/Vite/Parcel
- **Non-standard architecture** - Unique requirements
- **Specific bundler features** - Not available in Next.js
- **Electron apps** - Desktop applications

## Best Scenarios Summary

| Project Type           | Best Choice | Primary Reason                     |
| ---------------------- | ----------- | ---------------------------------- |
| **E-commerce Store**   | Next.js     | SEO + Performance + Dynamic Routes |
| **Blog/News Site**     | Next.js     | SEO + SSG for Fast Pages           |
| **Marketing Website**  | Next.js     | SEO + Fast Load Times              |
| **SaaS Landing Page**  | Next.js     | SEO + Performance Metrics          |
| **Documentation Site** | Next.js     | SEO + SSG + Search                 |
| **Portfolio Website**  | Next.js     | SEO + Professional Image           |
| **Social Media App**   | Next.js     | SEO for Profiles + Dynamic Content |
| **Admin Dashboard**    | React.js    | No SEO + Highly Interactive        |
| **Data Visualization** | React.js    | Client-Heavy + No SEO              |
| **Real-time Chat**     | React.js    | WebSocket Focus + Client-Side      |
| **Interactive Game**   | React.js    | Pure Client-Side + No SEO          |
| **Internal Tools**     | React.js    | No SEO + Existing Backend          |
| **Design Editor**      | React.js    | Canvas/WebGL + High Interactivity  |
| **Trading Platform**   | React.js    | Real-time + No SEO                 |

## Performance Metrics Comparison

### React.js App (CSR)

```
Typical Metrics:
â”œâ”€ Time to First Byte (TTFB):        ~100ms
â”œâ”€ First Contentful Paint (FCP):     ~2-3s    âš ï¸ Slow
â”œâ”€ Largest Contentful Paint (LCP):   ~3-4s    âš ï¸ Slow
â”œâ”€ Time to Interactive (TTI):        ~3-4s    âš ï¸ Slow
â”œâ”€ Cumulative Layout Shift (CLS):    Varies
â””â”€ SEO Score:                        60-70/100 âš ï¸ Poor

What happens:
1. Browser downloads HTML (empty)
2. Browser downloads JS bundle
3. Browser executes React
4. Browser fetches data
5. Browser renders content
```

### Next.js App (SSR)

```
Typical Metrics:
â”œâ”€ Time to First Byte (TTFB):        ~200-300ms
â”œâ”€ First Contentful Paint (FCP):     ~0.5-1s   âœ… Fast!
â”œâ”€ Largest Contentful Paint (LCP):   ~1-2s     âœ… Fast!
â”œâ”€ Time to Interactive (TTI):        ~1.5-2.5s âœ… Fast!
â”œâ”€ Cumulative Layout Shift (CLS):    ~0.05     âœ… Excellent
â””â”€ SEO Score:                        90-100/100 âœ… Excellent

What happens:
1. Browser downloads HTML (full content!)
2. Browser displays content immediately
3. Browser downloads JS bundle
4. Browser hydrates (adds interactivity)
```

### Next.js App (SSG)

```
Typical Metrics:
â”œâ”€ Time to First Byte (TTFB):        ~50ms     âœ… Instant!
â”œâ”€ First Contentful Paint (FCP):     ~0.3s     âœ… Instant!
â”œâ”€ Largest Contentful Paint (LCP):   ~0.5s     âœ… Instant!
â”œâ”€ Time to Interactive (TTI):        ~1s       âœ… Fast!
â”œâ”€ Cumulative Layout Shift (CLS):    ~0.01     âœ… Perfect
â””â”€ SEO Score:                        95-100/100 âœ… Perfect

What happens:
1. CDN serves pre-built HTML (instant!)
2. Browser displays content immediately
3. Browser downloads minimal JS
4. Browser hydrates (if needed)
```

## Migration Path

### From React to Next.js

#### Option 1: Gradual Migration (Recommended)

```
Phase 1: Setup
â”œâ”€ Create Next.js app
â”œâ”€ Configure routing
â””â”€ Add proxy to existing React app

Phase 2: Move Static Pages
â”œâ”€ Marketing pages
â”œâ”€ About page
â””â”€ Documentation

Phase 3: Move Dynamic Pages
â”œâ”€ Blog posts
â”œâ”€ Product pages
â””â”€ User profiles

Phase 4: Move Interactive Pages
â”œâ”€ Dashboard
â”œâ”€ Admin panel
â””â”€ User forms

Phase 5: Decommission React App
â”œâ”€ Remove proxy
â”œâ”€ Update DNS
â””â”€ Celebrate! ğŸ‰
```

#### Option 2: Full Migration

```bash
# 1. Create new Next.js project
npx create-next-app@latest my-app

# 2. Copy components
cp -r react-app/src/components nextjs-app/components

# 3. Convert pages
# React Router â†’ Next.js App Router
# react-app/src/pages/About.tsx â†’ nextjs-app/app/about/page.tsx

# 4. Update imports
# Remove React Router imports
# Use next/link instead

# 5. Move data fetching
# useEffect + fetch â†’ async Server Components

# 6. Test thoroughly
npm run build
npm start
```

## Common Misconceptions

### âŒ Myth: "Next.js is always better than React"

**Reality:** Not for SPAs, admin panels, or when SEO isn't needed.

### âŒ Myth: "React apps can't do SSR"

**Reality:** React can do SSR with libraries like Remix, but Next.js makes it easier.

### âŒ Myth: "Next.js requires Node.js server"

**Reality:** Can be exported as static site (`next export`) or deployed to Edge.

### âŒ Myth: "Next.js is slower than React"

**Reality:** Next.js is typically faster due to SSR/SSG and optimizations.

### âŒ Myth: "You need to learn React before Next.js"

**Reality:** Helpful but not required. Next.js teaches React along the way.

## Decision Matrix

Use this matrix to decide:

| Requirement       | React.js | Next.js |
| ----------------- | -------- | ------- |
| Need SEO          | âŒ       | âœ…      |
| Multiple pages    | âš ï¸       | âœ…      |
| Real-time data    | âœ…       | âš ï¸      |
| Behind login      | âœ…       | âœ…      |
| Fast initial load | âŒ       | âœ…      |
| Simple project    | âœ…       | âš ï¸      |
| Full-stack app    | âŒ       | âœ…      |
| Existing backend  | âœ…       | âœ…      |
| Static hosting    | âœ…       | âš ï¸      |
| Learning React    | âœ…       | âš ï¸      |

âœ… = Excellent fit  
âš ï¸ = Can work, but consider alternatives  
âŒ = Not ideal

## Conclusion

**Choose Next.js when:**

- SEO matters
- Performance is critical
- Building multi-page sites
- Want built-in optimizations

**Choose React.js when:**

- Building SPAs
- SEO not needed
- Maximum flexibility required
- Have existing backend

**Remember:** Both are excellent tools. The best choice depends on your specific project requirements, not which framework is "better."

---

**Previous:** [â† Next.js & SSR](./03-nextjs-and-ssr.md) | **Back to:** [README](./README.md)
